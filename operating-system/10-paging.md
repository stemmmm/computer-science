# 페이징

<details>  
<summary><h3>가상 메모리의 개념에 대해 설명하세요.</h3></summary>

- 실행하고자 하는 프로그램의 일부만 메모리에 적재하여 실제 물리적인 메모리 크기보다 더 큰 프로세스도 실행할 수 있게 하는 기술
- 물리 메모리 크기를 넘어서는 경우 디스크의 스왑 영역을 추가로 사용하기도 함
- 페이징, 세그멘테이션 등의 메모리 관리 기법을 활용해 가상 메모리를 구현함

<details>  
<summary><h4>가상 주소와 물리 주소의 차이는 무엇인가요?</h4></summary>

##### 가상 주소
- 각 프로세스가 독립적으로 가지는 논리적 주소
- 프로세스가 자신의 메모리에 접근하기 위해 사용하는 주소
- 가상 주소 공간은 각 프로세스마다 분리되어 다른 프로세스와 주소 충돌이 발생하지 않음
- 페이징 시스템에서의 가상 주소는 페이지 번호와 오프셋으로 이루어짐

##### 물리 주소
- 실제 메모리내의 주소
- 운영체제는 페이지 테이블을 이용해 가상 주소를 물리 주소로 변환하여 매핑함
- 모든 가상 주소는 MMU(Memory Management Unit)을 통해 물리 주소로 변환된 후 실제 메모리에 접근할 수 있음
</details>
</details>

<details>  
<summary><h3>페이징의 개념에 대해 설명하세요.</h3></summary>

- 가상 메모리와 물리 메모리를 동일한 크기의 블록 단위로 나누어 관리하는 기법
- 가상 메모리의 블록을 페이지, 물리 메모리의 블록을 프레임이라 부름
- 페이지가 실제로 메모리에 로드될 때, 페이지 테이블을 통해 가상 메모리의 페이지가 물리 메모리의 프레임에 매핑됨

<details>  
<summary><h4>페이징이 외부 단편화 문제를 해결하는 방식을 설명하세요.</h4></summary>

- 페이징에서는 모든 페이지와 프레임의 크기가 동일하게 고정되어 있으므로, 다양한 크기의 빈 공간이 생기지 않아 외부 단편화가 발생하지 않음
- 다만, 페이지 크기보다 작은 데이터가 들어올 경우 페이지 내부 공간이 낭비되는 내부 단편화 문제가 발생할 수 있음
</details>
</details>

<details>  
<summary><h3>내부 단편화의 개념에 대해 설명하세요.</h3></summary>

- 할당된 메모리 블록 내에서 사용되지 않은 여유 공간
- 고정 크기 메모리 블록에 데이터를 할당할 때, 데이터 크기보다 블록 크기가 클 경우 공간이 남게됨
- 예를 들어, 4KB 크기의 페이지에 3.5KB의 데이터를 할당하면 0.5KB가 낭비되며, 이 0.5KB가 내부 단편화임
</details>

<details>  
<summary><h3>페이지 크기에 따른 trade-off에 대해 설명하세요.</h3></summary>

| 요소         | 페이지 크기 작을 때 | 페이지 크기 클 때 |
|------------|-------------|------------|
| 내부 단편화     | 적음          | 큼          |
| 페이지 테이블 크기 | 큼           | 작음         |
| 디스크 I/O    | 많음          | 적음         |
</details>

<details>  
<summary><h3>페이지 테이블과 페이지 테이블 엔트리에 대해 설명하세요.</h3></summary>

#### 페이지 테이블
- 페이지와 프레임 간의 매핑 정보를 저장하는 테이블
- 각 프로세스는 독립적인 페이지 테이블을 가지며, 이를 통해 가상 주소를 물리 주소로 변환할 수 있음
- 페이지 테이블은 일반적으로 메인 메모리에 저장됨
<br>

#### 페이지 테이블 엔트리
- 페이지 테이블의 각 행들을 페이지 테이블 엔트리(PTE)라 부름
- 각 엔트리에는 페이지 번호, 프레임 번호, 유효 비트, 보호 비트, 참조 비트, 수정 비트 등이 포함됨

##### 페이지 번호
- 가상 주소에서 특정 페이지를 식별하는 번호

##### 프레임 번호
- 물리 주소에서 특정 프레임을 식별하는 번호
- 페이지 번호와 결합하여 실제 물리 메모리 위치를 찾을 수 있음

##### 유효 비트
- 페이지가 메모리 내에 존재하는지 여부를 나타내는 비트(1: 메모리에 존재, 0: 디스크에 존재)
- 유효 비트가 0이면 페이지 폴트가 발생함
- 페이지 폴트가 발생하면, CPU는 기존의 작업을 백업하고 페이지 폴트 처리 루틴을 실행함
- 페이지 폴트 처리 루틴은 해당 페이지를 디스크에서 메모리로 가져온 뒤, 유효 비트를 1로 변경하여 페이지를 사용할 수 있도록 함

##### 보호 비트
- 페이지에 대한 접근 권한(읽기, 쓰기, 실행)을 나타내는 비트

##### 참조 비트
- 페이지가 최근 참조되었는지를 나타내는 비트(1: 최근에 접근된 페이지, 0: 최근에 접근되지 않은 페이지)
- 운영체제는 참조 비트를 이용해 페이지 교체 알고리즘을 관리함

##### 수정 비트(Dirty Bit)
- 페이지가 수정된 적이 있는지를 나타내는 비트(1: 수정된 페이지, 0: 수정되지 않은 페이지)
- 수정된 페이지는 나중에 디스크에 데이터를 저장할 때, 변경 사항을 반영해 저장함
- 이를 통해 해당 페이지가 메모리에서 제거되기 전에 수정된 내용을 디스크에 반영할 수 있음
</details>

<details>  
<summary><h3>PTBR, MMU, TLB에 대해 설명하세요.</h3></summary>

#### PTBR(Page Table Base Register)
- 현재 실행 중인 프로세스의 페이지 테이블 시작 주소를 저장하는 레지스터
- 각 프로세스는 독립적인 페이지 테이블을 가지고 있으며, PTBR은 해당 프로세스의 페이지 테이블을 가리킴
- 예를 들어, 프로세스 A가 실행 중일 때, PTBR은 프로세스 A의 페이지 테이블을 가리킴
- 운영체제가 컨텍스트 스위칭을 할 때마다, PTBR은 각 프로세스의 페이지 테이블을 정확하게 참조할 수 있도록 도와줌

#### MMU(Memory Management Unit)
- 가상 주소를 물리 주소로 변환하는 하드웨어
- 페이지 테이블을 참조하여 가상 주소를 물리 주소로 변환함
- MMU는 PTBR을 통해 현재 프로세스의 페이지 테이블을 찾고, 페이지 번호를 기반으로 프레임 번호를 얻은 후, 오프셋을 더해 물리 주소를 생성함
- 페이지 폴트가 발생하면, MMU는 운영체제에 신호를 보내어 페이지 폴트 처리 루틴을 실행하도록 유도함

#### TLB(Translation Lookaside Buffer)
- 페이지 테이블 엔트리의 일부 정보를 캐시한 메모리
- MMU는 페이지 테이블을 조회하기 전에 TLB를 먼저 확인함  
- TLB 히트: TLB에 찾는 페이지가 있는 경우, MMU는 페이지 테이블을 조회하지 않고 물리 주소를 계산함
- TLB 미스: TLB에 찾는 페이지가 없는 경우, MMU는 페이지 테이블을 조회하여 물리 주소를 계산하고, 그 결과를 TLB에 저장해 이후 빠르게 접근할 수 있도록 함

<details>  
<summary><h4>MMU와 TLB는 어디에 위치해 있나요?</h4></summary>

- MMU: CPU 내부에 위치
- TLB: 일반적으로 MMU 내부에 위치
</details>

<details>  
<summary><h4>컨텍스트 스위칭 발생 시 TLB는 어떻게 되는지 설명하세요.</h4></summary>

- 새 프로세스는 자신만의 독립적인 페이지 테이블을 사용하므로, 이전 프로세스의 TLB 정보는 더이상 유효하지 않음
- 따라서 TLB를 플러시(flush)하여 모든 TLB 엔트리를 무효화(invalidate)해야 함
- 즉, 컨텍스트 스위칭 후 TLB는 비워지며, 새로운 프로세스에 알맞은 TLB 엔트리가 채워지기 전까지는 TLB 미스가 증가함
- 이로 인해 초기에는 페이지 테이블 조회가 늘어나고 성능 저하가 발생할 수 있지만, 새로운 프로세스의 TLB가 다시 채워지면 성능이 회복됨
</details>

<details>  
<summary><h4>코어가 여러 개인 경우 TLB는 어떻게 동기화 할 수 있을까요?</h4></summary>

- 멀티 코어 시스템에서는 각 코어마다 독립적인 TLB를 가질 수 있기 때문에, 페이지 테이블이 수정될 때 TLB의 일관성 문제가 발생할 수 있음
- 페이지 테이블이 수정되면 해당 정보를 캐시하고 있는 TLB가 최신 정보를 반영하지 않을 수 있어, TLB 미스가 발생하거나 잘못된 주소 변환이 일어날 수 있음
- 이를 해결하기 위해 모든 코어의 TLB를 플러시하거나 특정 코어의 TLB를 플러시할 수 있음
</details>
</details>

<details>  
<summary><h3>페이징에서 Copy on Write에 대해 설명하세요.</h3></summary>

- 부모 프로세스에서 `fork()` 시스템 콜을 호출하면 자식 프로세스는 부모 프로세스의 페이지 테이블 엔트리를 복사함
- 이로 인해 부모와 자식 프로세스는 동일한 프레임을 참조하며, 부모와 자식의 페이지 테이블 엔트리는 읽기 전용(read only)으로 설정됨
- 만약 부모나 자식 프로세스가 데이터를 수정하려고 하면, 읽기 전용 설정으로 인해 페이지 폴트가 발생함 
- 운영체제는 페이지 폴트가 발생하면, 수정 대상 페이지를 복사하여 새로운 메모리 공간에 저장하고, 수정하려는 프로세스의 페이지 테이블 엔트리가 새로운 프레임을 가리키도록 함
- COW를 사용하면 `fork()` 이후 쓰기 작업이 없는 경우 메모리를 절약할 수 있고, 프로세스 생성 속도도 높일 수 있음
</details>

<details>  
<summary><h3>FIFO 페이지 교체 알고리즘에 대해 설명하세요.</h3></summary>

- 메모리에 페이지가 올라온 순서대로 교체하는 방식
- 즉, 가장 오래된 페이지를 먼저 교체함
- 구현은 간단하지만, 성능 측면에서 최적의 방법은 아님
</details>

<details>  
<summary><h3>2차 기회 페이지 교체 알고리즘에 대해 설명하세요.</h3></summary>

- FIFO 알고리즘의 단점을 어느정도 보완한 방식
- 기본적으로 FIFO와 마찬가지로 가장 오래된 페이지를 내보내지만, 페이지의 참조 비트가 1일 경우(참조된 적이 있는 경우) 해당 비트를 0으로 만들고, 페이지를 최근에 적재된 페이지로 취급함
- 즉, 한 번 더 기회를 받게 되어 자주 참조되는 페이지가 불필요하게 교체되지 않도록 함
</details>

<details>  
<summary><h3>최적 페이지 교체 알고리즘에 대해 설명하세요.</h3></summary>

- 가장 나중에 사용될 페이지를 교체하는 방식
- 이론적으로 최소 페이지 교체 횟수(가장 낮은 페이지 폴트 수)를 보장하는 알고리즘으로, 페이지 교체 알고리즘 중 가장 이상적인 방식임
- 그러나 실제 운영체제에서는 미래에 참조될 페이지를 예측할 수 없기 때문에 구현이 어려움
- 따라서 최적 페이지 교체 알고리즘은 일반적으로 다른 알고리즘의 성능 평가를 위한 기준으로 사용됨
</details>

<details>  
<summary><h3>LRU 페이지 교체 알고리즘에 대해 설명하세요.</h3></summary>

- 가장 오래전에 사용된 페이지를 교체하는 방식(Least Recently Used)
- '최근에 참조된 페이지는 가까운 미래에 다시 참조될 가능성이 높다'는 가정을 기반으로 한 알고리즘

<details>  
<summary><h4>프로세스가 사용할 수 있는 프레임이 3개 있고, 페이지 참조열이 [4, 2, 3, 4, 1, 2, 3, 5, 4, 3]일 때, LRU 알고리즘을 사용하면 몇 번의 페이지 폴트가 발생하나요?</h4></summary>

- 답: 8번
</details>
</details>

<details>  
<summary><h3>Thrashing의 개념과 완화법에 대해 설명하세요.</h3></summary>

#### 개념
- 시스템의 물리 메모리 공간이 부족하여 페이지가 너무 자주 교체되는 현상
- 지나친 페이지 교체로 인해 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소모하게 되어 CPU 이용률이 낮아지는 문제

#### 완화법
- 물리 메모리(RAM) 용량 확장
- 적절한 페이지 교체 알고리즘 선택
- 실행 중인 프로세스 수 줄이기
</details>

<details>  
<summary><h3>프레임 할당 방식에 대해 설명하세요.</h3></summary>

#### 개념
- 운영체제가 프로세스에 할당할 프레임 수를 결정하는 방식
- 잘못된 프레임 할당은 스래싱(thrashing)을 유발해 시스템 성능이 저하될 수 있음

<br>

#### 정적 프레임 할당 방식
- 프로세스를 시작할 때 고정적으로 프레임을 할당하는 방식
- 균등 할당 방식: 모든 프로세스에 동일한 수의 프레임을 할당하는 방식
- 비례 할당 방식: 각 프로세스의 크기나 메모리 요구 사항에 비례하여 프레임을 할당하는 방식

<br>

#### 동적 프레임 할당 방식
- 프로세스가 실행되는 동안 프로세스의 메모리 요구 사항에 따라 동적으로 프레임을 할당하는 방식
- 작업 집합 모델 기반: 실행 중인 프로세스가 일정 시간 동안 참조한 페이지들의 집합인 작업 집합을 기준으로 프레임을 할당하는 방식
- 페이지 폴트 빈도 기반: 페이지 폴트가 적게 발생하는 프로세스의 프레임을 회수하여 페이지 폴트가 자주 발생하는 프로세스에 프레임을 추가 할당하는 방식 
</details>

---

<details>  
<summary><h3>페이징과 세그멘테이션의 차이에 대해 설명하세요.</h3></summary>

<details>  
<summary><h4>현대 운영체제에서 페이징이 세그멘테이션보다 더 자주 사용되는 이유는 무엇인가요?</h4></summary>

</details>
</details>

<details>  
<summary><h3>32비트 시스템에서 페이지의 크기가 1KB라면 페이지 테이블의 최대 크기는 몇개일까요?</h3></summary>

</details>

<details>  
<summary><h3>32비트 시스템에서는 램을 최대 4G까지 사용할 수 있는데, 그 이유를 페이징과 연관지어 설명하세요.</h3></summary>

</details>

<details>  
<summary><h3>멀티레벨 페이징에 대해 설명하세요.</h3></summary>

- 가상 메모리가 매우 클 때 단일 페이지 테이블을 사용하는 방식의 비효율성을 해결하기 위해 사용되며, 2단계 페이징이나 3단계 페이징 등이 있음
- 멀티레벨 페이징에서는 페이지 테이블을 여러 계층으로 나누어 메모리 사용을 최적화함
- 전체 페이지 테이블을 메모리에 로드하지 않고, 필요한 페이지 테이블만 동적으로 할당해 메모리 사용량을 절약함
- 가상 주소는 계층 구조에 따라 페이지 디렉토리 인덱스, 페이지 테이블 인덱스, 페이지 오프셋으로 나뉨
</details>